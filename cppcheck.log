src/audio/internal.h:54:0: error: failed to expand 'US_FLOAT', Invalid ## usage when expanding 'US_FLOAT'. [preprocessorErrorDirective]
#define US_FLOAT(x) x ## f
^
src/engine/level_script.c:435:17: warning: Redundant assignment of 'behaviorArg' to itself. [selfAssignment]
    behaviorArg = behaviorArg;
                ^
src/engine/math_util.c:164:23: portability: Casting from float * * to unsigned int * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
    register u32 *d = (u32 *) dest;
                      ^
src/engine/math_util.c:165:23: portability: Casting from float * * to unsigned int * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
    register u32 *s = (u32 *) src;
                      ^
src/game/hud.c:32:9: style: struct member 'PowerMeterHUD::unused' is never used. [unusedStructMember]
    f32 unused;
        ^
src/game/hud.c:36:9: style: struct member 'UnusedHUDStruct::unused1' is never used. [unusedStructMember]
    u32 unused1;
        ^
src/game/hud.c:37:9: style: struct member 'UnusedHUDStruct::unused2' is never used. [unusedStructMember]
    u16 unused2;
        ^
src/game/hud.c:38:9: style: struct member 'UnusedHUDStruct::unused3' is never used. [unusedStructMember]
    u16 unused3;
        ^
src/game/ingame_menu.c:1311:5: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
    linePos += textLengths[multiTextId].length;
    ^
src/game/ingame_menu.c:866:29: style: Assignment 'currentIndex[0]=maxIndex' is redundant with condition 'currentIndex[0]==maxIndex'. [duplicateConditionalAssign]
            currentIndex[0] = maxIndex;
                            ^
src/game/ingame_menu.c:864:29: note: Condition 'currentIndex[0]==maxIndex'
        if (currentIndex[0] == maxIndex) {
                            ^
src/game/ingame_menu.c:866:29: note: Assignment 'currentIndex[0]=maxIndex' is redundant
            currentIndex[0] = maxIndex;
                            ^
src/game/ingame_menu.c:785:17: style: Finding the same value in both branches of ternary operator is suspicious as the same code is executed regardless of the condition. [duplicateValueTernary]
                gDPLoadBlock(gDisplayListHead++, G_TX_LOADTILE, 0, 0, 8 * 8 - 1, CALC_DXT(8, G_IM_SIZ_8b_BYTES));
                ^
src/game/ingame_menu.c:793:21: style: Finding the same value in both branches of ternary operator is suspicious as the same code is executed regardless of the condition. [duplicateValueTernary]
                    gDPLoadBlock(gDisplayListHead++, G_TX_LOADTILE, 0, 0, 8 * 8 - 1, CALC_DXT(8, G_IM_SIZ_8b_BYTES));
                    ^
src/game/ingame_menu.c:1084:68: style: Finding the same expression on both sides of an operator is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct. [duplicateExpression]
                    sInterpolatedDialogScale = gDialogBoxScale - 2 / 2;
                                                                   ^
src/game/ingame_menu.c:1087:68: style: Finding the same expression on both sides of an operator is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct. [duplicateExpression]
                    sInterpolatedDialogScale = gDialogBoxScale + 2 / 2;
                                                                   ^
src/game/ingame_menu.c:1100:68: style: Finding the same expression on both sides of an operator is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct. [duplicateExpression]
                    sInterpolatedDialogScale = gDialogBoxScale - 2 / 2;
                                                                   ^
src/game/ingame_menu.c:1102:68: style: Finding the same expression on both sides of an operator is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct. [duplicateExpression]
                    sInterpolatedDialogScale = gDialogBoxScale + 2 / 2;
                                                                   ^
src/game/mario.c:1283:46: warning: Either the condition 'm->squishTimer<=16' is redundant or the array 'sSquishScaleOverTime[16]' is accessed at index -1, which is out of bounds. [negativeIndex]
                1.0f - ((sSquishScaleOverTime[15 - m->squishTimer] * 0.6f) / 100.0f);
                                             ^
src/game/mario.c:1279:33: note: Assuming that condition 'm->squishTimer<=16' is not redundant
        else if (m->squishTimer <= 16) {
                                ^
src/game/mario.c:1283:46: note: Negative array index
                1.0f - ((sSquishScaleOverTime[15 - m->squishTimer] * 0.6f) / 100.0f);
                                             ^
src/pc/debuglog.h:15:17: style: Obsolete function 'asctime' called. It is recommended to use 'strftime' instead. [asctimeCalled]
    char* str = asctime(&ltime2);
                ^
src/pc/logfile.h:34:17: style: Obsolete function 'asctime' called. It is recommended to use 'strftime' instead. [asctimeCalled]
    char* str = asctime(&ltime2);
                ^
src/game/mario_actions_moving.c:1243:51: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
            play_sound(m->flags & MARIO_METAL_CAP ? SOUND_ACTION_METAL_BONK : SOUND_ACTION_BONK,
                                                  ^
src/game/mario_actions_cutscene.c:1548:47: portability: Shifting a negative value is technically undefined behaviour [shiftNegativeLHS]
        m->fadeWarpOpacity = (-m->actionTimer << 3) + 0xF8;
                                              ^
src/game/mario_actions_cutscene.c:134:49: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
        strY = (sDispCreditsEntry->unk02 & 0x20 ? 28 : 172) + (numLines == 1) * 16;
                                                ^
src/game/mario_actions_cutscene.c:612:55: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
    speed = gPlayer1Controller->buttonDown & B_BUTTON ? 1 : 4;
                                                      ^
src/game/mario_actions_cutscene.c:755:46: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
        set_mario_action(m, m->actionArg & 1 ? ACT_STAR_DANCE_NO_EXIT : ACT_STAR_DANCE_EXIT,
                                             ^
src/game/mario_actions_cutscene.c:1505:39: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
        m, m->flags & MARIO_METAL_CAP ? SOUND_ACTION_METAL_JUMP : SOUND_ACTION_TERRAIN_JUMP, 1);
                                      ^
src/game/mario_actions_cutscene.c:1658:68: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
                    m->hurtCounter += m->flags & MARIO_CAP_ON_HEAD ? 12 : 18;
                                                                   ^
src/game/mario_actions_cutscene.c:2796:50: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
                (gCurrCreditsEntry->unk02 & 0x10 ? width : -width) * 56 / 100 + 640;
                                                 ^
src/game/mario_actions_cutscene.c:2798:50: style: Suspicious calculation. Please use parentheses to clarify the code. The code ''a&b?c:d'' should be written as either ''(a&b)?c:d'' or ''a&(b?c:d)''. [clarifyCalculation]
                (gCurrCreditsEntry->unk02 & 0x20 ? height : -height) * 66 / 100 + 480;
                                                 ^
src/game/mario_actions_moving.c:702:28: error: Uninitialized variable: dWallAngle [uninitvar]
    if (m->wall == NULL || dWallAngle <= -0x71C8 || dWallAngle >= 0x71C8) {
                           ^
src/game/bettercamera.inc.h:374:20: style: Condition 'newcam_analogue' is always true [knownConditionTrueFalse]
        } else if (newcam_analogue) {
                   ^
src/game/bettercamera.inc.h:346:25: note: Assuming that condition 'newcam_analogue==1' is not redundant
    if (newcam_analogue == 1) {
                        ^
src/game/bettercamera.inc.h:374:20: note: Condition 'newcam_analogue' is always true
        } else if (newcam_analogue) {
                   ^
src/game/camera.c:4385:9: style: Redundant initialization for 'yaw'. The initialized value is overwritten before it is read. [redundantInitialization]
    yaw = calculate_yaw(origin, pos);
        ^
src/game/camera.c:4371:13: note: yaw is initialized
    s16 yaw = gCamera->nextYaw;
            ^
src/game/camera.c:4385:9: note: yaw is overwritten
    yaw = calculate_yaw(origin, pos);
        ^
src/game/camera.c:11516:19: style: Redundant initialization for 'targetFoV'. The initialized value is overwritten before it is read. [redundantInitialization]
        targetFoV = 45.f;
                  ^
src/game/camera.c:11513:19: note: targetFoV is initialized
    f32 targetFoV = sFOVState.fov;
                  ^
src/game/camera.c:11516:19: note: targetFoV is overwritten
        targetFoV = 45.f;
                  ^
src/game/camera.c:11536:19: style: Redundant initialization for 'targetFoV'. The initialized value is overwritten before it is read. [redundantInitialization]
        targetFoV = 60.f;
                  ^
src/game/camera.c:11533:19: note: targetFoV is initialized
    f32 targetFoV = sFOVState.fov;
                  ^
src/game/camera.c:11536:19: note: targetFoV is overwritten
        targetFoV = 60.f;
                  ^
src/game/camera.c:5468:9: style: Finding variables 'distTimer' and 'angleTimer' that are assigned the same expression is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct. [duplicateAssignExpression]
    f32 distTimer = sModeTransition.framesLeft;
        ^
src/game/camera.c:5469:9: note: Same expression used in consecutive assignments of 'distTimer' and 'angleTimer'.
    s16 angleTimer = sModeTransition.framesLeft;
        ^
src/game/camera.c:5468:9: note: Same expression used in consecutive assignments of 'distTimer' and 'angleTimer'.
    f32 distTimer = sModeTransition.framesLeft;
        ^
src/game/camera.c:7062:39: style: Finding the same expression on both sides of an operator is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct. [duplicateExpression]
        } while ((src[j].index != -1) && (src[j].index != -1)); //! same comparison performed twice
                                      ^
src/game/bettercamera.inc.h:692:24: warning: Undefined behaviour: float (257.55) to integer conversion overflow. [floatConversionOverflow]
            newcam_xlu = (newcam_coldist-150)*2.55f;
                       ^
src/game/bettercamera.inc.h:690:24: note: Assuming that condition 'newcam_coldist<=250' is not redundant
    if (newcam_coldist <= 250 && (newcam_coldist-150)*2.55f < 255) {
                       ^
src/game/bettercamera.inc.h:692:24: note: float to integer conversion
            newcam_xlu = (newcam_coldist-150)*2.55f;
                       ^
src/game/mario_misc.c:96:5: error: Shifting 32-bit value by 32 bits is undefined behaviour [shiftTooManyBits]
    DEFINE_PLAYER_COLOR(0xf9, 0xeb, 0x30, /**/ 0x7f, 0x20, 0x7a),
    ^
src/game/profiler.c:83:9: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
        clockStart = 319;
        ^
src/game/profiler.c:86:9: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
        clockEnd = 319;
        ^
src/game/object_list_processor.c:510:20: style: Local variable 'unused' shadows outer argument [shadowArgument]
        UNUSED s32 unused;
                   ^
src/game/object_list_processor.c:490:41: note: Shadowed declaration
void spawn_objects_from_info(UNUSED s32 unused, struct SpawnInfo *spawnInfo) {
                                        ^
src/game/object_list_processor.c:510:20: note: Shadow variable
        UNUSED s32 unused;
                   ^
src/game/object_list_processor.c:537:69: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
                    u16 playerIndex = (spawnInfo->behaviorArg & ~(1 << 31));
                                                                    ^
src/game/save_file.c:150:63: error: Subtracting pointers that point to different objects [comparePointers]
    const uintptr_t ofs = (u8*)&gSaveBuffer.files[file][slot] - (u8*)&gSaveBuffer;
                                                              ^
src/game/save_file.h:72:21: note: Variable declared here.
    struct SaveFile files[NUM_SAVE_FILES][2];
                    ^
src/game/save_file.c:150:32: note: Address of variable taken here.
    const uintptr_t ofs = (u8*)&gSaveBuffer.files[file][slot] - (u8*)&gSaveBuffer;
                               ^
src/game/save_file.c:25:26: note: Variable declared here.
extern struct SaveBuffer gSaveBuffer;
                         ^
src/game/save_file.c:150:70: note: Address of variable taken here.
    const uintptr_t ofs = (u8*)&gSaveBuffer.files[file][slot] - (u8*)&gSaveBuffer;
                                                                     ^
src/game/save_file.c:150:63: note: Subtracting pointers that point to different objects
    const uintptr_t ofs = (u8*)&gSaveBuffer.files[file][slot] - (u8*)&gSaveBuffer;
                                                              ^
src/game/save_file.c:165:60: error: Subtracting pointers that point to different objects [comparePointers]
    const uintptr_t ofs = (u8*)&gSaveBuffer.menuData[slot] - (u8*)&gSaveBuffer;
                                                           ^
src/game/save_file.h:74:29: note: Variable declared here.
    struct MainMenuSaveData menuData[2];
                            ^
src/game/save_file.c:165:32: note: Address of variable taken here.
    const uintptr_t ofs = (u8*)&gSaveBuffer.menuData[slot] - (u8*)&gSaveBuffer;
                               ^
src/game/save_file.c:25:26: note: Variable declared here.
extern struct SaveBuffer gSaveBuffer;
                         ^
src/game/save_file.c:165:67: note: Address of variable taken here.
    const uintptr_t ofs = (u8*)&gSaveBuffer.menuData[slot] - (u8*)&gSaveBuffer;
                                                                  ^
src/game/save_file.c:165:60: note: Subtracting pointers that point to different objects
    const uintptr_t ofs = (u8*)&gSaveBuffer.menuData[slot] - (u8*)&gSaveBuffer;
                                                           ^
src/goddard/debug_utils.c:445:18: warning: Either the condition 'sNumRoutinesInStack>=(int)(sizeof(sRoutineNames)/sizeof(sRoutineNames[0]))' is redundant or the array 'sRoutineNames[64]' is accessed at index 64, which is out of bounds. [arrayIndexOutOfBoundsCond]
    sRoutineNames[sNumRoutinesInStack] = NULL;
                 ^
src/goddard/debug_utils.c:447:29: note: Assuming that condition 'sNumRoutinesInStack>=(int)(sizeof(sRoutineNames)/sizeof(sRoutineNames[0]))' is not redundant
    if (sNumRoutinesInStack >= ARRAY_COUNT(sRoutineNames)) {
                            ^
src/goddard/debug_utils.c:445:18: note: Array index out of bounds
    sRoutineNames[sNumRoutinesInStack] = NULL;
                 ^
src/goddard/draw_objects.c:482:13: style: Condition 'hasTextCoords' is always false [knownConditionTrueFalse]
        if (hasTextCoords) {
            ^
src/goddard/draw_objects.c:448:21: note: Assignment 'hasTextCoords=0', assigned value is 0
    hasTextCoords = FALSE;
                    ^
src/goddard/draw_objects.c:482:13: note: Condition 'hasTextCoords' is always false
        if (hasTextCoords) {
            ^
src/goddard/draw_objects.c:96:9: style: struct member 'Anonymous1::pad00' is never used. [unusedStructMember]
    u32 pad00;            // @ 801B9CE0
        ^
src/goddard/dynlist_proc.c:412:9: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
        sprintf(buf, "N%d", DynIdAsInt(id));
        ^
src/goddard/dynlist_proc.c:549:9: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
        sprintf(idbuf, "N%d", DynIdAsInt(id));
        ^
src/goddard/dynlist_proc.c:592:9: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
        sprintf(sIntDynIdBuffer, "N%d", DynIdAsInt(id));
        ^
src/goddard/dynlist_proc.c:2923:13: style: Consecutive return, break, continue, goto or throw statements are unnecessary. The second statement can never be executed, and so should be removed. [duplicateBreak]
            break; // lol
            ^
src/goddard/old_menu.c:73:9: warning: %d in format string (no. 2) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
        sprintf(buf, "| %s %%x%d", group->name, (u32) (uintptr_t) group);
        ^
src/goddard/particles.c:250:49: style: Finding the same expression on both sides of an operator is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct. [duplicateExpression]
    if (vtx1->header.type == OBJ_TYPE_PARTICLES && vtx1->header.type == OBJ_TYPE_PARTICLES) {
                                                ^
src/goddard/shape_helper.c:377:13: style: Consecutive return, break, continue, goto or throw statements are unnecessary. The second statement can never be executed, and so should be removed. [duplicateBreak]
            continue; // unreachable
            ^
src/goddard/shape_helper.c:402:13: style: Consecutive return, break, continue, goto or throw statements are unnecessary. The second statement can never be executed, and so should be removed. [duplicateBreak]
            continue; // unreachable + nonsensical
            ^
src/goddard/shape_helper.c:26:9: style: struct member 'UnkData::a' is never used. [unusedStructMember]
    s32 a, b;
        ^
src/goddard/shape_helper.c:27:21: style: struct member 'UnkData::self' is never used. [unusedStructMember]
    struct UnkData *self;
                    ^
src/goddard/shape_helper.c:900:16: style: struct member 'Anonymous2::pad' is never used. [unusedStructMember]
            u8 pad[0x40];
               ^
src/goddard/shape_helper.c:902:17: style: struct member 'Anonymous2::word44' is never used. [unusedStructMember]
            s32 word44;
                ^
src/goddard/shape_helper.c:926:17: style: struct member 'Anonymous8::nv' is never used. [unusedStructMember]
            f32 nv[3]; /* Guessing on the normals; they aren't used */
                ^
src/menu/intro_geo.c:106:21: style: Condition 'sp50==1' is always true [knownConditionTrueFalse]
    } else if (sp50 == 1) {
                    ^
src/menu/intro_geo.c:104:14: note: Assuming that condition 'sp50!=1' is not redundant
    if (sp50 != 1) {
             ^
src/menu/intro_geo.c:106:21: note: Condition 'sp50==1' is always true
    } else if (sp50 == 1) {
                    ^
src/menu/intro_geo.c:149:21: style: Condition 'sp40==1' is always true [knownConditionTrueFalse]
    } else if (sp40 == 1) {
                    ^
src/menu/intro_geo.c:147:14: note: Assuming that condition 'sp40!=1' is not redundant
    if (sp40 != 1) {
             ^
src/menu/intro_geo.c:149:21: note: Condition 'sp40==1' is always true
    } else if (sp40 == 1) {
                    ^
src/pc/configfile.c:231:9: error: Common realloc mistake: 'buffer' nulled but not freed upon failure [memleakOnRealloc]
        buffer = realloc(buffer, bufferSize);
        ^
src/pc/discord/discordrpc.c:30:0: error: #error Unknown System [preprocessorErrorDirective]
# error Unknown System
^
src/menu/file_select.c:2272:49: error: Array 'textMarioAJustErased[1]' accessed at index 6, which is out of bounds. [arrayIndexOutOfBounds]
            LANGUAGE_ARRAY(textMarioAJustErased)[MARIO_ERASED_VAR] = sSelectedFileIndex + 10;
                                                ^
src/menu/file_select.c:2307:38: style: The statement 'if (sStatusMessageID!=ERASE_MSG_PROMPT) sStatusMessageID=ERASE_MSG_PROMPT' is logically equivalent to 'sStatusMessageID=ERASE_MSG_PROMPT'. [duplicateConditionalAssign]
                if (sStatusMessageID != ERASE_MSG_PROMPT) {
                                     ^
src/menu/file_select.c:2308:38: note: Assignment 'sStatusMessageID=ERASE_MSG_PROMPT'
                    sStatusMessageID = ERASE_MSG_PROMPT;
                                     ^
src/menu/file_select.c:2307:38: note: Condition 'sStatusMessageID!=ERASE_MSG_PROMPT' is redundant
                if (sStatusMessageID != ERASE_MSG_PROMPT) {
                                     ^
src/pc/djui/djui_checkbox.c:36:6: warning: Either the condition 'base!=(void*)0' is redundant or there is possible null pointer dereference: checkbox. [nullPointerRedundantCheck]
    *checkbox->value = !(*checkbox->value);
     ^
src/pc/djui/djui_checkbox.c:38:14: note: Assuming that condition 'base!=(void*)0' is not redundant
    if (base != NULL && base->interactable != NULL && base->interactable->on_value_change != NULL) {
             ^
src/pc/djui/djui_checkbox.c:35:37: note: Assignment 'checkbox=(struct DjuiCheckbox*)base', assigned value is 0
    struct DjuiCheckbox* checkbox = (struct DjuiCheckbox*)base;
                                    ^
src/pc/djui/djui_checkbox.c:36:6: note: Null pointer dereference
    *checkbox->value = !(*checkbox->value);
     ^
src/pc/djui/djui_checkbox.c:37:56: warning: Either the condition 'base!=(void*)0' is redundant or there is possible null pointer dereference: checkbox. [nullPointerRedundantCheck]
    djui_base_set_visible(&checkbox->rectValue->base, *checkbox->value);
                                                       ^
src/pc/djui/djui_checkbox.c:38:14: note: Assuming that condition 'base!=(void*)0' is not redundant
    if (base != NULL && base->interactable != NULL && base->interactable->on_value_change != NULL) {
             ^
src/pc/djui/djui_checkbox.c:35:37: note: Assignment 'checkbox=(struct DjuiCheckbox*)base', assigned value is 0
    struct DjuiCheckbox* checkbox = (struct DjuiCheckbox*)base;
                                    ^
src/pc/djui/djui_checkbox.c:37:56: note: Null pointer dereference
    djui_base_set_visible(&checkbox->rectValue->base, *checkbox->value);
                                                       ^
src/goddard/renderer.c:2812:13: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
            fmt = 3;
            ^
src/goddard/renderer.c:2820:13: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
            size = 2;
            ^
src/goddard/renderer.c:934:25: style: Consecutive return, break, continue, goto or throw statements are unnecessary. The second statement can never be executed, and so should be removed. [duplicateBreak]
                        break; // needed to match
                        ^
src/goddard/renderer.c:2188:5: style: Consecutive return, break, continue, goto or throw statements are unnecessary. The second statement can never be executed, and so should be removed. [duplicateBreak]
    return; // @ 801A17A8
    ^
src/pc/djui/djui_hud_utils.c:128:23: warning: Logical conjunction always evaluates to false: c == '\n' && c == ' '. Are these conditions necessary? Did you intend to use || instead? Are the numbers correct? Are you comparing the correct variables? [incorrectLogicOperator]
        if (c == '\n' && c == ' ') {
                      ^
src/pc/djui/djui_inputbox.c:113:15: style: The unsigned expression 'i' will never be negative so it is either pointless or an error to check if it is. [unsignedLessThanZero]
        if (i <= 0)   { i = 0;   break; }
              ^
src/goddard/renderer.c:83:32: style: struct member 'DynListBankInfo::list' is never used. [unusedStructMember]
    /* 0x04 */ struct DynList *list;
                               ^
src/pc/djui/djui_panel_host.c:93:13: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
            snprintf(portString, 32, "%d", configHostPort);
            ^
src/pc/djui/djui_panel_join.c:119:9: warning: %d in format string (no. 2) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
        snprintf(buffer, 256, "%s:%d", configJoinIp, configJoinPort);
        ^
src/pc/djui/djui_panel_host_settings.c:102:13: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
            snprintf(limitString, 32, "%d", configAmountofPlayers);
            ^
src/pc/djui/djui_selectionbox.c:50:13: warning: Either the condition 'base!=(void*)0' is redundant or there is possible null pointer dereference: selectionbox. [nullPointerRedundantCheck]
    f32 x = selectionbox->rect->base.elem.x;
            ^
src/pc/djui/djui_selectionbox.c:54:18: note: Assuming that condition 'base!=(void*)0' is not redundant
        if (base != NULL && base->interactable != NULL && base->interactable->on_value_change != NULL) {
                 ^
src/pc/djui/djui_selectionbox.c:49:45: note: Assignment 'selectionbox=(struct DjuiSelectionbox*)base', assigned value is 0
    struct DjuiSelectionbox* selectionbox = (struct DjuiSelectionbox*)base;
                                            ^
src/pc/djui/djui_selectionbox.c:50:13: note: Null pointer dereference
    f32 x = selectionbox->rect->base.elem.x;
            ^
src/pc/fs/fs.c:225:16: style: Non-boolean value returned from function returning bool [returnNonBoolInBooleanFunction]
    if (!file) return -1;
               ^
src/pc/djui/djui_slider.c:48:18: warning: Either the condition 'base!=(void*)0' is redundant or there is possible null pointer dereference: slider. [nullPointerRedundantCheck]
    u32  min   = slider->min;
                 ^
src/pc/djui/djui_slider.c:57:14: note: Assuming that condition 'base!=(void*)0' is not redundant
    if (base != NULL && base->interactable != NULL && base->interactable->on_value_change != NULL) {
             ^
src/pc/djui/djui_slider.c:47:33: note: Assignment 'slider=(struct DjuiSlider*)base', assigned value is 0
    struct DjuiSlider* slider = (struct DjuiSlider*)base;
                                ^
src/pc/djui/djui_slider.c:48:18: note: Null pointer dereference
    u32  min   = slider->min;
                 ^
src/pc/djui/djui_slider.c:49:18: warning: Either the condition 'base!=(void*)0' is redundant or there is possible null pointer dereference: slider. [nullPointerRedundantCheck]
    u32  max   = slider->max;
                 ^
src/pc/djui/djui_slider.c:57:14: note: Assuming that condition 'base!=(void*)0' is not redundant
    if (base != NULL && base->interactable != NULL && base->interactable->on_value_change != NULL) {
             ^
src/pc/djui/djui_slider.c:47:33: note: Assignment 'slider=(struct DjuiSlider*)base', assigned value is 0
    struct DjuiSlider* slider = (struct DjuiSlider*)base;
                                ^
src/pc/djui/djui_slider.c:49:18: note: Null pointer dereference
    u32  max   = slider->max;
                 ^
src/pc/djui/djui_slider.c:50:18: warning: Either the condition 'base!=(void*)0' is redundant or there is possible null pointer dereference: slider. [nullPointerRedundantCheck]
    u32* value = slider->value;
                 ^
src/pc/djui/djui_slider.c:57:14: note: Assuming that condition 'base!=(void*)0' is not redundant
    if (base != NULL && base->interactable != NULL && base->interactable->on_value_change != NULL) {
             ^
src/pc/djui/djui_slider.c:47:33: note: Assignment 'slider=(struct DjuiSlider*)base', assigned value is 0
    struct DjuiSlider* slider = (struct DjuiSlider*)base;
                                ^
src/pc/djui/djui_slider.c:50:18: note: Null pointer dereference
    u32* value = slider->value;
                 ^
src/pc/djui/djui_slider.c:51:13: warning: Either the condition 'base!=(void*)0' is redundant or there is possible null pointer dereference: slider. [nullPointerRedundantCheck]
    f32 x = slider->rect->base.elem.x;
            ^
src/pc/djui/djui_slider.c:57:14: note: Assuming that condition 'base!=(void*)0' is not redundant
    if (base != NULL && base->interactable != NULL && base->interactable->on_value_change != NULL) {
             ^
src/pc/djui/djui_slider.c:47:33: note: Assignment 'slider=(struct DjuiSlider*)base', assigned value is 0
    struct DjuiSlider* slider = (struct DjuiSlider*)base;
                                ^
src/pc/djui/djui_slider.c:51:13: note: Null pointer dereference
    f32 x = slider->rect->base.elem.x;
            ^
src/pc/djui/djui_slider.c:52:13: warning: Either the condition 'base!=(void*)0' is redundant or there is possible null pointer dereference: slider. [nullPointerRedundantCheck]
    f32 w = slider->rect->base.elem.width;
            ^
src/pc/djui/djui_slider.c:57:14: note: Assuming that condition 'base!=(void*)0' is not redundant
    if (base != NULL && base->interactable != NULL && base->interactable->on_value_change != NULL) {
             ^
src/pc/djui/djui_slider.c:47:33: note: Assignment 'slider=(struct DjuiSlider*)base', assigned value is 0
    struct DjuiSlider* slider = (struct DjuiSlider*)base;
                                ^
src/pc/djui/djui_slider.c:52:13: note: Null pointer dereference
    f32 w = slider->rect->base.elem.width;
            ^
src/pc/djui/djui_slider.c:85:18: warning: Either the condition 'base!=(void*)0' is redundant or there is possible null pointer dereference: slider. [nullPointerRedundantCheck]
    int value = *slider->value;
                 ^
src/pc/djui/djui_slider.c:90:14: note: Assuming that condition 'base!=(void*)0' is not redundant
    if (base != NULL && base->interactable != NULL && base->interactable->on_value_change != NULL) {
             ^
src/pc/djui/djui_slider.c:83:33: note: Assignment 'slider=(struct DjuiSlider*)base', assigned value is 0
    struct DjuiSlider* slider = (struct DjuiSlider*)base;
                                ^
src/pc/djui/djui_slider.c:85:18: note: Null pointer dereference
    int value = *slider->value;
                 ^
src/pc/djui/djui_slider.c:89:6: warning: Either the condition 'base!=(void*)0' is redundant or there is possible null pointer dereference: slider. [nullPointerRedundantCheck]
    *slider->value = value;
     ^
src/pc/djui/djui_slider.c:90:14: note: Assuming that condition 'base!=(void*)0' is not redundant
    if (base != NULL && base->interactable != NULL && base->interactable->on_value_change != NULL) {
             ^
src/pc/djui/djui_slider.c:83:33: note: Assignment 'slider=(struct DjuiSlider*)base', assigned value is 0
    struct DjuiSlider* slider = (struct DjuiSlider*)base;
                                ^
src/pc/djui/djui_slider.c:89:6: note: Null pointer dereference
    *slider->value = value;
     ^
src/pc/fs/fs_packtype_zip.c:132:18: style: struct member 'lfh_s::version_required' is never used. [unusedStructMember]
        uint16_t version_required;
                 ^
src/pc/fs/fs_packtype_zip.c:135:18: style: struct member 'lfh_s::mod_time' is never used. [unusedStructMember]
        uint16_t mod_time;
                 ^
src/pc/fs/fs_packtype_zip.c:136:18: style: struct member 'lfh_s::mod_date' is never used. [unusedStructMember]
        uint16_t mod_date;
                 ^
src/pc/fs/fs_packtype_zip.c:167:18: style: struct member 'cdh_s::version_used' is never used. [unusedStructMember]
        uint16_t version_used;
                 ^
src/pc/fs/fs_packtype_zip.c:168:18: style: struct member 'cdh_s::version_required' is never used. [unusedStructMember]
        uint16_t version_required;
                 ^
src/pc/fs/fs_packtype_zip.c:171:18: style: struct member 'cdh_s::mod_time' is never used. [unusedStructMember]
        uint16_t mod_time;
                 ^
src/pc/fs/fs_packtype_zip.c:172:18: style: struct member 'cdh_s::mod_date' is never used. [unusedStructMember]
        uint16_t mod_date;
                 ^
src/pc/fs/fs_packtype_zip.c:179:18: style: struct member 'cdh_s::start_disk' is never used. [unusedStructMember]
        uint16_t start_disk;
                 ^
src/pc/gfx/gfx_opengl.c:635:74: style: Condition 'is_es' is always false [knownConditionTrueFalse]
        sys_fatal("OpenGL 2.1+ is required.\nReported version: %s%d.%d", is_es ? "ES" : "", vmajor, vminor);
                                                                         ^
src/pc/gfx/gfx_opengl.c:634:37: note: Assuming that condition '!is_es' is not redundant
    if (vmajor < 2 && vminor < 1 && !is_es)
                                    ^
src/pc/gfx/gfx_opengl.c:635:74: note: Condition 'is_es' is always false
        sys_fatal("OpenGL 2.1+ is required.\nReported version: %s%d.%d", is_es ? "ES" : "", vmajor, vminor);
                                                                         ^
src/pc/gfx/gfx_pc.c:1878:11: style: Finding variables 'minX' and 'maxX' that are assigned the same expression is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct. [duplicateAssignExpression]
    float minX = rsp.loaded_vertices[start_index].x;
          ^
src/pc/gfx/gfx_pc.c:1879:11: note: Same expression used in consecutive assignments of 'minX' and 'maxX'.
    float maxX = rsp.loaded_vertices[start_index].x;
          ^
src/pc/gfx/gfx_pc.c:1878:11: note: Same expression used in consecutive assignments of 'minX' and 'maxX'.
    float minX = rsp.loaded_vertices[start_index].x;
          ^
src/pc/gfx/gfx_pc.c:1880:11: style: Finding variables 'minY' and 'maxY' that are assigned the same expression is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct. [duplicateAssignExpression]
    float minY = rsp.loaded_vertices[start_index].y;
          ^
src/pc/gfx/gfx_pc.c:1881:11: note: Same expression used in consecutive assignments of 'minY' and 'maxY'.
    float maxY = rsp.loaded_vertices[start_index].y;
          ^
src/pc/gfx/gfx_pc.c:1880:11: note: Same expression used in consecutive assignments of 'minY' and 'maxY'.
    float minY = rsp.loaded_vertices[start_index].y;
          ^
src/pc/gfx/gfx_pc.c:1883:11: style: Finding variables 'minU' and 'maxU' that are assigned the same expression is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct. [duplicateAssignExpression]
    float minU = rsp.loaded_vertices[start_index].u;
          ^
src/pc/gfx/gfx_pc.c:1884:11: note: Same expression used in consecutive assignments of 'minU' and 'maxU'.
    float maxU = rsp.loaded_vertices[start_index].u;
          ^
src/pc/gfx/gfx_pc.c:1883:11: note: Same expression used in consecutive assignments of 'minU' and 'maxU'.
    float minU = rsp.loaded_vertices[start_index].u;
          ^
src/pc/gfx/gfx_pc.c:1885:11: style: Finding variables 'minV' and 'maxV' that are assigned the same expression is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct. [duplicateAssignExpression]
    float minV = rsp.loaded_vertices[start_index].v;
          ^
src/pc/gfx/gfx_pc.c:1886:11: note: Same expression used in consecutive assignments of 'minV' and 'maxV'.
    float maxV = rsp.loaded_vertices[start_index].v;
          ^
src/pc/gfx/gfx_pc.c:1885:11: note: Same expression used in consecutive assignments of 'minV' and 'maxV'.
    float minV = rsp.loaded_vertices[start_index].v;
          ^
src/pc/lua/smlua_cobject.c:86:9: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
        LOG_LUA("_get_field on invalid LOT '%u'", lot);
        ^
src/pc/lua/smlua_cobject.c:92:9: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
        LOG_LUA("_get_field received a pointer not in allow list. '%u', '%llu", lot, (u64)pointer);
        ^
src/pc/lua/smlua_cobject.c:160:9: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
        LOG_LUA("_set_field on invalid LOT '%u'", lot);
        ^
src/pc/lua/smlua_cobject.c:166:9: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
        LOG_LUA("_set_field received a pointer not in allow list. '%u', '%llu", lot, (u64)pointer);
        ^
src/pc/lua/smlua_cobject.c:113:50: portability: Casting between unsigned char * and float * which have an incompatible binary data representation. [invalidPointerCast]
        case LVT_F32:        lua_pushnumber( L, *(f32*)p);              break;
                                                 ^
src/pc/lua/smlua_cobject.c:194:24: portability: Casting between unsigned char * and float * which have an incompatible binary data representation. [invalidPointerCast]
        case LVT_F32: *(f32*)p = smlua_to_number(L, -1);  break;
                       ^
src/pc/lua/smlua_cobject.c:53:23: style: Finding the same expression on both sides of an operator is suspicious and might indicate a cut and paste or logic error. Please examine this code carefully to determine if it is correct. [knownConditionTrueFalse]
        if (min > max || max < min) {
                      ^
src/pc/lua/smlua_hooks.c:56:13: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
            LOG_LUA("Failed to call the event_hook callback: %u, %s", hookType, lua_tostring(L, -1));
            ^
src/pc/lua/smlua_hooks.c:79:13: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
            LOG_LUA("Failed to call the callback: %u, %s", hookType, lua_tostring(L, -1));
            ^
src/pc/lua/smlua_hooks.c:108:13: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
            LOG_LUA("Failed to call the callback: %u, %s", hookType, lua_tostring(L, -1));
            ^
src/pc/lua/smlua_hooks.c:140:13: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
            LOG_LUA("Failed to call the callback: %u, %s", hookType, lua_tostring(L, -1));
            ^
src/pc/lua/smlua_hooks.c:163:13: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
            LOG_LUA("Failed to call the callback: %u, %s", hookType, lua_tostring(L, -1));
            ^
src/pc/lua/smlua_functions.c:15:9: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
        LOG_LUA("improper param count: expected %u, received %u", expected, top);
        ^
src/pc/lua/smlua_functions.c:15:9: warning: %u in format string (no. 2) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
        LOG_LUA("improper param count: expected %u, received %u", expected, top);
        ^
src/pc/lua/smlua_functions.c:25:9: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
        LOG_LUA("improper param count: expected (%u - %u), received %u", min, max, top);
        ^
src/pc/lua/smlua_functions.c:25:9: warning: %u in format string (no. 2) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
        LOG_LUA("improper param count: expected (%u - %u), received %u", min, max, top);
        ^
src/pc/lua/smlua_functions.c:25:9: warning: %u in format string (no. 3) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
        LOG_LUA("improper param count: expected (%u - %u), received %u", min, max, top);
        ^
src/pc/lua/smlua_sync_table.c:176:12: warning: Redundant assignment of 'lntKey' to itself. [selfAssignment]
    lntKey = lntKey;
           ^
src/pc/lua/smlua_obj_utils.c:54:13: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
            LOG_LUA("Failed to call the callback: %u, %s", objSetupFunction, lua_tostring(L, -1));
            ^
src/pc/network/ban_list.c:17:9: error: Common realloc mistake: 'gBanAddresses' nulled but not freed upon failure [memleakOnRealloc]
        gBanAddresses = realloc(gBanAddresses, sizeof(char*) * gBanCount);
        ^
src/pc/network/ban_list.c:19:9: error: Common realloc mistake: 'gBanPerm' nulled but not freed upon failure [memleakOnRealloc]
        gBanPerm = realloc(gBanPerm, sizeof(bool) * gBanCount);
        ^
src/pc/network/discord/activity.c:26:9: style: Consecutive return, break, continue, goto or throw statements are unnecessary. The second statement can never be executed, and so should be removed. [duplicateBreak]
        return;
        ^
src/pc/network/discord/lobby.c:40:5: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
    LOGFILE_INFO(LFT_DISCORD, "Lobby type: %u", lobby->type);
    ^
src/pc/network/network_player.c:306:19: style: Expression is always false because 'else if' condition matches previous condition at line 304. [multiCondition]
        } else if (matchingLocal && gNetworkPlayerLocal->currCourseNum != 0) {
                  ^
src/pc/network/packets/packet_debug_sync.c:11:20: warning: Redundant assignment of 'behaviorId' to itself. [selfAssignment]
        behaviorId = behaviorId; // suppress warning
                   ^
src/pc/network/packets/packet_level_spawn_info.c:108:32: style: The unsigned expression 'spawnInfoDeletionCount' will never be negative so it is either pointless or an error to check if it is. [unsignedLessThanZero]
    if (spawnInfoDeletionCount <= 0) { return; }
                               ^
src/pc/network/socket/domain_res.c:19:15: style: Redundant initialization for 'host_name'. The initialized value is overwritten before it is read. [redundantInitialization]
    host_name = configJoinIp;
              ^
src/pc/network/socket/domain_res.c:16:21: note: host_name is initialized
    char *host_name = configJoinIp;
                    ^
src/pc/network/socket/domain_res.c:19:15: note: host_name is overwritten
    host_name = configJoinIp;
              ^
src/pc/network/socket/socket.c:89:9: warning: %d in format string (no. 2) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
        snprintf(joinText, 63, "%s %d", configJoinIp, configJoinPort);
        ^
